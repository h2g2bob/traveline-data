<!DOCTYPE html>
<html>
<head>
<!--
- factor out hard-coded lat/lng/zoom
- color lines by frequency
- make curvy lines
- hook up some panning / scrolling mechanism
-->
<title>Bus routes</title>
<style type="text/css">
svg {
	background: #003366;
}

svg path {
	fill: white;
	fill-opacity: 0;
	stroke: white;
	stroke-opacity: 1;
	stroke-width: 1px;
}

svg path[frequency=high] {
}
svg path[frequency=medium] {
	opacity: 0.3;
}
svg path[frequency=low] {
	opacity: 0.1;
}

svg circle.stop {
	opacity: 0;
	fill: #ffff80;
	stroke: none;
}
svg circle.stop:hover {
	opacity: 0.5;
}

.fullscreen {
	height: 100vh;
	width: 100vw;
	margin: 0;
	padding: 0;
	border: 0;
	overflow: hidden;
}

#controls {
	position: absolute;
	top: 0;
	right: 0;
	background: #000000;
	color: #00cc00;
}
#controls button {
	width: 10vw;
	height: 10vh;
}

#stop_name {
	position: absolute;
	bottom: 0;
	right: 0;
	background: #000000;
	color: #00cc00;
}

</style>
<script type="application/javascript">

function Box(minlng, maxlng, minlat, maxlat) {
	this.minlng = minlng;
	this.maxlng = maxlng;
	this.minlat = minlat;
	this.maxlat = maxlat;
}
Box.prototype = {
	width: function () {
		return this.maxlng - this.minlng;
	},

	height: function () {
		return this.maxlat - this.minlat;
	},

	toString: function () {
		return "Box(" + this.minlng + ", " + this.maxlng + ", " + this.minlat + ", " + this.maxlat + ")";
	}
}

function TravelineDataMap(container, paint, lng, lat) {
	this.container = container;
	this.paint = paint;

	/* current top-left position, call pan() after changing this */
	this.lat = lat;
	this.lng = lng;

	/* set this.data_already_requested */
	this.zero_requested_data();
}
TravelineDataMap.prototype = {
	zero_requested_data: function () {
		/* currently we "requested" just a single point -- but we can build from this one point */
		this.paint.clear();
		this.data_already_requested = new Box(this.lng, this.lng, this.lat, this.lat);
	},

	current_viewport: function () {
		return new Box(
			this.lng,
			this.lng + this.paint.descale(this.container.offsetWidth),
			this.lat,
			this.lat + this.paint.descale(this.container.offsetHeight)
		);
	},

	fetch_more_data: function () {
		this.paint.debug_show_requested_data("requested", this.data_already_requested, "stroke: #800000; fill: transparent;");

		var next_download = this.calculate_region_to_dowload_next();

		if (next_download !== null) {
			var debug_name = "next_" + Math.random()
			this.paint.debug_show_requested_data(debug_name, next_download, "stroke: transparent; fill: #" + (Math.random() < 0.5?"ff":"00") + (Math.random() < 0.5?"ff":"00") + (Math.random() < 0.5?"ff":"00") + "; opacity: 0.05;");

			console.log("should download " + next_download);

			var url = "/json/?lat=" + next_download.minlat + "&lng=" + next_download.minlng + "&width=" + next_download.width() + "&height=" + next_download.height();
			var that = this;
			var callback = function () {
				if (xmlhttpreq.readyState == 4) {
					that.paint.add_data(JSON.parse(xmlhttpreq.responseText));
				}
			};

			var xmlhttpreq = new XMLHttpRequest();
			xmlhttpreq.addEventListener("load", callback);
			xmlhttpreq.open("GET", url);
			xmlhttpreq.send();
		}
	},

	pan: function() {
		this.paint.svg.setAttribute("transform", "translate(" + this.paint.scale(-this.lng) + "," + this.paint.scale(-this.lat) + ")");
	},

	calculate_region_to_dowload_next: function () {
		var desired = this.current_viewport();
		this.paint.debug_show_requested_data("viewport", desired, "stroke: #008080; fill: transparent;");

		var max_single_request_size = 0.1;

		if (desired.maxlat > this.data_already_requested.maxlat) {
			/* expand down */
			var old_maxlat = this.data_already_requested.maxlat;
			this.data_already_requested.maxlat = Math.min(
				desired.maxlat,
				this.data_already_requested.maxlat + max_single_request_size)
			return new Box(
				this.data_already_requested.minlng,
				this.data_already_requested.maxlng,
				old_maxlat,
				this.data_already_requested.maxlat
			);
		} else if (desired.minlat < this.data_already_requested.minlat) {
			/* expand up */
			var old_minlat = this.data_already_requested.minlat;
			this.data_already_requested.minlat = Math.max(
				desired.minlat,
				this.data_already_requested.minlat - max_single_request_size)
			return new Box(
				this.data_already_requested.minlng,
				this.data_already_requested.maxlng,
				this.data_already_requested.minlat,
				old_minlat
			);
		} else if (desired.maxlng > this.data_already_requested.maxlng) {
			/* expand right */
			var old_maxlng = this.data_already_requested.maxlng;
			this.data_already_requested.maxlng = Math.min(
				desired.maxlng,
				this.data_already_requested.maxlng + max_single_request_size)
			return new Box(
				old_maxlng,
				this.data_already_requested.maxlng,
				this.data_already_requested.minlat,
				this.data_already_requested.maxlat
			);
		} else if (desired.minlng < this.data_already_requested.minlng) {
			/* expand left */
			var old_minlng = this.data_already_requested.minlng;
			this.data_already_requested.minlng = Math.max(
				desired.minlng,
				this.data_already_requested.minlng - max_single_request_size)
			return new Box(
				this.data_already_requested.minlng,
				old_minlng,
				this.data_already_requested.minlat,
				this.data_already_requested.maxlat
			);
		} else {
			return null;
		}
	},

	run: function () {
		this.pan();
		window.setInterval(this.fetch_more_data.bind(this), 100);
	}
}

function TLDataPaint(svg) {
	this.zoom = 5000;
	this.svg = svg;
}
TLDataPaint.prototype = {
	scale: function (value) {
		/*
		you might think this is possible from transform=scale(1000) and
		stroke-width: 0.001px, but this only makes either invisible or
		thick lines
		*/
		return value * this.zoom;
	},

	descale: function (value) {
		return value / this.zoom;
	},

	add_data: function (data) {
		var paint = this;
		data["pairs"].forEach(function (pair) {
			var path_id = "path_" + pair["from"] + "_" + pair["to"];
			if (document.getElementById(path_id) === null) {
				var path_desc = paint.path_description(data, pair);
				if (path_desc !== null) {
					var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
					path.setAttribute("id", path_id);
					path.setAttribute("d", path_desc);
					path.setAttribute("frequency", paint.frequency_label(pair["frequency"]));
					paint.svg.appendChild(path);
				}
			}
		});
		for (var key in data["stops"]) {
			if (!data["stops"].hasOwnProperty(key)) {
				continue;
			}
			var stop_id = "stop_" + key;
			var stop = data["stops"][key];
			if (document.getElementById(stop_id) === null) {
				var circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
				circ.setAttribute("id", stop_id);
				circ.setAttribute("cx", this.scale(stop["lng"]));
				circ.setAttribute("cy", this.scale(stop["lat"]));
				circ.setAttribute("r", 5);
				circ.setAttribute("class", "stop");
				circ.setAttribute("data-stop-id", key);
				circ.setAttribute("data-stop-name", stop["name"]);
				paint.svg.appendChild(circ);
			}
		};
	},

	clear: function() {
		for (var child = this.svg.firstChild; child !== null; child = this.svg.firstChild) {
			this.svg.removeChild(child);
		}
	},

	debug_show_requested_data: function (name, box, style) {
		var path = document.getElementById(name);
		if (path == undefined) {
			var path = document.createElementNS("http://www.w3.org/2000/svg", "rect");
			path.setAttribute("id", name);
			path.setAttribute("class", "debug-download-indication");

			// add this at the top of the element list, so that it gets rendered first
			// ie: underneath the stops, which have user interaction
			// this is ugly because most browsers ignore z-index in svg:
			// https://developer.mozilla.org/en-US/docs/Web/SVG/SVG_2_support_in_Mozilla#Painting
			// oh, and insertChild cannot have a null option, fuck you w3c
			if (this.svg.firstChild !== undefined) {
				this.svg.insertBefore(path, this.svg.firstChild);
			} else {
				this.svg.appendChild(path);
			}
		}
		path.setAttribute("y", this.scale(box.minlat));
		path.setAttribute("x", this.scale(box.minlng));
		path.setAttribute("height", this.scale(box.maxlat - box.minlat));
		path.setAttribute("width", this.scale(box.maxlng - box.minlng));
		path.setAttribute("style", style);
	},

	path_description: function (data, pair) {
		var from_stop = data["stops"][pair["from"]];
		var to_stop = data["stops"][pair["to"]];
		if (from_stop === undefined || to_stop === undefined) {
			return null;
		}
		return "M " + this.scale(from_stop["lng"]) + " " + this.scale(from_stop["lat"]) + " L " + this.scale(to_stop["lng"]) + " " + this.scale(to_stop["lat"]);
	},

	frequency_label: function(buses_per_hour) {
		if (buses_per_hour >= 4) {
			return "high";
		} else if (buses_per_hour >= 2) {
			return "medium";
		} else {
			return "low";
		}
	}
};

window.addEventListener("load", function () {
	var paint = new TLDataPaint(document.getElementById("map_paint_area"));
	window.travelinedatamap = new TravelineDataMap(document.getElementById("map_paint_container"), paint, 0.698, 51.566);
	window.travelinedatamap.run();

	var step_size = 100

	function do_zoom(scale) {
		paint.zoom *= scale;

		/* positions of lines on the canvas change when zoom changes */
		window.travelinedatamap.zero_requested_data();

		/* which also means the pan position changes */
		window.travelinedatamap.pan();
	}

	window.addEventListener("keyup", function (event) {
		switch (event.key) {
			case "q":
				do_zoom(1.5);
				break;
			case "e":
				do_zoom(1/1.5);
				break;
			case "w":
				window.travelinedatamap.lat -= step_size/window.travelinedatamap.paint.zoom;
				window.travelinedatamap.pan();
				break;
			case "s":
				window.travelinedatamap.lat += step_size/window.travelinedatamap.paint.zoom;
				window.travelinedatamap.pan();
				break;
			case "a":
				window.travelinedatamap.lng -= step_size/window.travelinedatamap.paint.zoom;
				window.travelinedatamap.pan();
				break;
			case "d":
				window.travelinedatamap.lng += step_size/window.travelinedatamap.paint.zoom;
				window.travelinedatamap.pan();
				break;
		}
	});

	var drag_elem = document.getElementById("map_paint_container");
	var drag_start_x = undefined;
	var drag_start_y = undefined;
	drag_elem.addEventListener("mousedown", function (event) {
		drag_start_x = event.screenX;
		drag_start_y = event.screenY;
	}, false);
	drag_elem.addEventListener("mouseup", function (event) {
		drag_start_x = undefined;
		drag_start_y = undefined;
	}, false);
	drag_elem.addEventListener("mousemove", function (event) {
		if (drag_start_x !== undefined && drag_start_y !== undefined) {
			var change_x = event.screenX - drag_start_x;
			var change_y = event.screenY - drag_start_y;
			drag_start_x = event.screenX;
			drag_start_y = event.screenY;
			window.travelinedatamap.lat -= change_y/window.travelinedatamap.paint.zoom;
			window.travelinedatamap.lng -= change_x/window.travelinedatamap.paint.zoom;
			window.travelinedatamap.pan();
		}
	}, false);

	function add_control(label, action) {
		var btn = document.createElement("button");
		btn.textContent = label;
		btn.addEventListener("click", action, false);
		document.getElementById("controls").appendChild(btn);
	}
	add_control("+", function () { do_zoom(1.5); });
	add_control("-", function () { do_zoom(1/1.5); });
	add_control("N", function () {
		window.travelinedatamap.lat -= step_size/window.travelinedatamap.paint.zoom;
		window.travelinedatamap.pan();
	});
	add_control("S", function () {
		window.travelinedatamap.lat += step_size/window.travelinedatamap.paint.zoom;
		window.travelinedatamap.pan();
	});
	add_control("W", function () {
		window.travelinedatamap.lng -= step_size/window.travelinedatamap.paint.zoom;
		window.travelinedatamap.pan();
	});
	add_control("E", function () {
		window.travelinedatamap.lng += step_size/window.travelinedatamap.paint.zoom;
		window.travelinedatamap.pan();
	});

	window.addEventListener("mouseover", function (event) {
		if (event.target) {
			var stop_id = event.target.getAttribute("data-stop-id");
			var stop_name = event.target.getAttribute("data-stop-name");
			if (stop_name) {
				document.getElementById("stop_name").textContent = stop_id + ": " + stop_name;
			}
		}
	});
});



</script>
</head>
<body class="fullscreen">
<div id="map_paint_container" class="fullscreen"><svg style="width: 100%; height: 100%" xmlns="http://www.w3.org/2000/svg">
	<g id="map_paint_area">
	</g>
</svg></div>
<div id="controls"></div>
<div id="stop_name"></div>
</body>
